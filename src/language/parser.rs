#![allow(unused)]

use std::iter::Peekable;

use plex::lexer;

use crate::language::ast::AST;
use crate::language::ast::Binding;
use crate::language::ast::Function;
use crate::language::ast::Value;
use crate::language::bultins::BuiltinFunction;
use crate::language::errors::Error;
use crate::language::parser::precedence::*;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TokenType {
    Whitespace,
    Error,

    // Literals
    IntLit,
    StringLit,
    True,
    False,
    Name,
    CellName,

    LParen,
    RParen,
    LBrack,
    RBrack,
    LBrace,
    RBrace,

    // Punctuation
    Comma,
    Dot,
    Colon,
    SemiColon,
    Arrow,
    Eq,

    // Number Operators
    Plus,
    Minus,
    Star,

    // Boolean Operators
    And,
    Or,
    Not,

    // Comparison Operators
    EqEq,
    NotEq,
    Gt,
    GtEq,
    Lt,
    LtEq,

    // Misc Operators
    PlusPlus,   // List concatenation
    SlashSlash, // Record merge

    // Keywords
    Fn,
    Let,
    In,
    If,
    Then,
    Else,
}

#[derive(Debug, Clone, Copy)]
pub struct Token<'a> {
    pub token_type: TokenType,
    pub text: &'a str,
}

// Lexer generated by plex
lexer! {
    fn next_token(_text: 'a) -> TokenType;

    r#"[ \t\n\r]+"# => TokenType::Whitespace,

    r#"\("# => TokenType::LParen,
    r#"\)"# => TokenType::RParen,

    r#"\["# => TokenType::LBrack,
    r#"\]"# => TokenType::RBrack,

    r#"{"# => TokenType::LBrace,
    r#"}"# => TokenType::RBrace,

    r#"and"# => TokenType::And,
    r#"or"# => TokenType::Or,
    r#"not"# => TokenType::Not,
    r#"!"# => TokenType::Not,
    r#"=="# => TokenType::EqEq,
    r#"!="# => TokenType::NotEq,
    r#">"# => TokenType::Gt,
    r#">="# => TokenType::GtEq,
    r#"<"# => TokenType::Lt,
    r#"<="# => TokenType::LtEq,

    r#"\+\+"# => TokenType::PlusPlus,
    r#"//"# => TokenType::SlashSlash,

    r#","# => TokenType::Comma,
    r#"\."# => TokenType::Dot,
    r#":"# => TokenType::Colon,
    r#";"# => TokenType::SemiColon,
    r#"->"# => TokenType::Arrow,
    r#"="# => TokenType::Eq,

    r#"\+"# => TokenType::Plus,
    r#"-"# => TokenType::Minus,
    r#"\*"# => TokenType::Star,

    r#"[0-9]+"# => TokenType::IntLit,
    r#""[^"]*""# => TokenType::StringLit, //TODO escape chars

    r#"fn"# => TokenType::Fn,
    r#"let"# => TokenType::Let,
    r#"in"# => TokenType::In,
    r#"true"# => TokenType::True,
    r#"false"# => TokenType::False,

    r#"if"# => TokenType::If,
    r#"then"# => TokenType::Then,
    r#"else"# => TokenType::Else,

    // Cell names are regular names prefixed with a $ to specifically indicate cell references
    r#"$[a-zA-Z_][a-zA-Z0-9_]*"# => TokenType::CellName,
    r#"[a-zA-Z_][a-zA-Z0-9_]*"# => TokenType::Name,

    r#"."# => TokenType::Error,
}

struct Lexer<'a> {
    current: &'a str,
}

impl<'a> Lexer<'a> {
    fn new(text: &'a str) -> Lexer<'a> {
        Lexer { current: text }
    }
}

pub fn validate_name(name: &str) -> bool {
    let mut lexer = Lexer::new(name);
    lexer.next().map_or(false, |t| t.token_type == TokenType::Name) && lexer.next().is_none()
}

impl<'a> Iterator for Lexer<'a> {
    type Item = Token<'a>;

    fn next(&mut self) -> Option<Token<'a>> {
        loop {
            let token = next_token(self.current).map(|(t, rest)| {
                let token = Token {
                    token_type: t,
                    text: &self.current[0..self.current.len() - rest.len()],
                };
                self.current = rest;
                token
            });
            if let Some(Token {
                token_type: TokenType::Whitespace,
                ..
            }) = token
            {
                continue;
            } else {
                return token;
            }
        }
    }
}

macro_rules! token_type {
    ($token_type:ident) => {
        Some(Token {
            token_type: TokenType::$token_type,
            ..
        })
    };

    ($token_type:ident, $text:pat) => {
        Some(Token {
            token_type: TokenType::$token_type,
            text: $text,
        })
    };
}

pub struct Parser<'a> {
    tokens: Peekable<Lexer<'a>>,
}

impl Error {
    fn parse_error(message: impl Into<String>) -> Self {
        Error::with_message(format!("Parse Error: {}", message.into()))
    }
}

/// Parses a string into an abstract syntax tree (AST).
///
/// Returns an error if the string is not a valid expression.
pub fn parse(text: &str) -> Result<AST, Error> {
    let mut parser = Parser::new(text);
    let expr = parser.parse_expr(BindingPower::zero())?;
    match parser.next() {
        None => Ok(expr),
        Some(t) => Err(Error::parse_error(format!("Unexpected token: {}", t.text))),
    }
}

impl<'a> Iterator for Parser<'a> {
    type Item = Token<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        self.tokens.next()
    }
}

impl<'a> Parser<'a> {
    fn new(text: &'a str) -> Self {
        Self {
            tokens: Lexer::new(text).peekable(),
        }
    }

    pub fn peek(&mut self) -> Option<&Token<'a>> {
        self.tokens.peek()
    }

    /// Expect the next token to be of the given type.
    ///
    /// If the next token is of the given type, returns the token.
    /// Otherwise, returns an error.
    fn expect_token(&mut self, token_type: TokenType) -> Result<Token<'a>, Error> {
        match self.next() {
            Some(t) if t.token_type == token_type => Ok(t),
            _ => Err(Error::parse_error("Unexpected token")),
        }
    }

    /// Returns the next token if it matches the given token type.
    ///
    /// If the next token does not match the given token type, returns None.
    ///
    /// This is a convenience function for when you want to consume the next token
    /// only if it matches a certain type, but do not want to generate an error if
    /// it does not match.
    fn next_if_eq(&mut self, token_type: TokenType) -> Option<Token<'a>> {
        self.tokens.next_if(|t| t.token_type == token_type)
    }
    
    /// Parses an expression from the given parser.
    ///
    /// The expression is parsed with a minimum binding power of `min_bp`.
    /// This means that any operator with a binding power less than `min_bp`
    /// will not be parsed as part of the expression.
    ///
    /// Returns the parsed expression, or an error if the expression is invalid.
    fn parse_expr(&mut self, min_bp: BindingPower) -> Result<AST, Error> {
        // Generates a pattern for a token struct which matches a specific token type

        let mut lhs;

        macro_rules! token_type {
            ($token_type:ident) => {
                Some(Token {
                    token_type: TokenType::$token_type,
                    ..
                })
            };

            ($token_type:ident, $text:pat) => {
                Some(Token {
                    token_type: TokenType::$token_type,
                    text: $text,
                })
            };
        }

        // Parses a comma seperated list of a given parser, terminated by a close token
        macro_rules! separated_by {
            ($separator:ident, $parse:expr, $close:ident) => {{
                let mut collect = vec![];
                if self.next_if_eq(TokenType::$close).is_none() {
                    collect.push($parse);
                    while self.next_if_eq(TokenType::$separator).is_some() {
                        collect.push($parse);
                    }
                    self.expect_token(TokenType::$close)?;
                }
                collect
            }};
        }

        // Handles infix operators
        // Specify the precidence and the literal string used to represent the operator in the AST
        macro_rules! infix_op {
            ($prec:expr, $assoc:ident, $func:ident) => {{
                let prec = BindingPower::infix($prec, Assoc::$assoc);
                if should_break(&prec, &min_bp)? {
                    break;
                }
                self.tokens.next();
                let rhs = self.parse_expr(prec)?;
                lhs = AST::function(BuiltinFunction::$func, vec![lhs, rhs]);
            }};

            ($prec:expr, $assoc:ident, $func:expr) => {{
                let prec = BindingPower::infix($prec, Assoc::$assoc);
                if should_break(&prec, &min_bp)? {
                    break;
                }
                self.tokens.next();
                let rhs = self.parse_expr(prec)?;
                lhs = $func(rhs);
            }};
        }

        macro_rules! prefix_op {
            ($prec:expr, $func:ident) => {{
                let rhs = self.parse_expr(BindingPower::prefix($prec))?;
                AST::function(BuiltinFunction::$func, vec![rhs])
            }};
        }

        macro_rules! postfix_op {
            ($prec:expr, $func:expr) => {{
                if should_break(&BindingPower::postfix($prec), &min_bp)? {
                    break;
                }
                self.tokens.next();
                lhs = $func;
            }};
        }

        lhs = match self.next() {
            // Integer Literals
            token_type!(IntLit, text) => AST::Literal(Value::Integer(
                text.parse()
                    .map_err(|_| Error::parse_error("Invalid int"))?,
            )),

            // String Literals
            // Trim the quotes
            token_type!(StringLit, text) => {
                AST::Literal(Value::String(text[1..text.len() - 1].to_string()))
            } //TODO escape chars

            // List Literals
            token_type!(LBrack) => {
                let elements = separated_by!(Comma, self.parse_expr(BindingPower::zero())?, RBrack);
                AST::Literal(Value::List(elements))
            }

            // Record Literals
            token_type!(LBrace) => {
                let elements = separated_by!(
                    Comma,
                    {
                        let name = self.expect_token(TokenType::Name)?.text.to_string();
                        self.expect_token(TokenType::Colon)?;
                        let value = self.parse_expr(BindingPower::zero())?;
                        (name, value)
                    },
                    RBrace
                );
                AST::Literal(Value::Record(elements.into_iter().collect()))
            }

            // Boolean literals
            token_type!(True) => AST::Literal(Value::Boolean(true)),
            token_type!(False) => AST::Literal(Value::Boolean(false)),

            // Names
            token_type!(Name, text) => AST::Name(text.to_string()),
            token_type!(CellName, text) => AST::Name(text.to_string()),

            token_type!(Fn) => {
                self.expect_token(TokenType::LParen)?;
                let params = separated_by!(
                    Comma,
                    self.expect_token(TokenType::Name)?.text.to_string(),
                    RParen
                );
                self.expect_token(TokenType::Arrow)?;
                let body = self.parse_expr(BindingPower::zero())?;
                AST::Literal(Value::Function(Function::Lambda(params, Box::new(body))))
            }

            token_type!(Let) => {
                let bindings = separated_by!(
                    SemiColon,
                    {
                        let name = self.expect_token(TokenType::Name)?.text.to_string();
                        self.expect_token(TokenType::Eq)?;
                        let expr = self.parse_expr(BindingPower::zero())?;
                        Binding(name, expr)
                    },
                    In
                );
                let expr = self.parse_expr(BindingPower::zero())?;
                AST::Let(bindings, Box::new(expr))
            }

            // Brackets
            token_type!(LParen) => {
                let expr = self.parse_expr(BindingPower::zero())?;
                self.expect_token(TokenType::RParen)?;
                expr
            }

            // Prefix operators
            token_type!(Minus) => prefix_op!(9, Negate),
            token_type!(Not) => prefix_op!(9, Not),

            // If-Then-Else
            token_type!(If) => {
                let cond = self.parse_expr(BindingPower::zero())?;
                self.expect_token(TokenType::Then)?;
                let then = self.parse_expr(BindingPower::zero())?;
                self.expect_token(TokenType::Else)?;
                let else_ = self.parse_expr(BindingPower::prefix(1))?;
                AST::function(BuiltinFunction::If, vec![cond, then, else_])
            }

            _ => return Err(Error::parse_error("Expected name or lit int")),
        };

        loop {
            match self.peek() {
                // Postfix operators
                token_type!(Dot) => postfix_op!(10, {
                    let field = self.expect_token(TokenType::Name)?.text.to_string();
                    AST::FieldAccess(Box::new(lhs), field)
                }),
                token_type!(LParen) => postfix_op!(10, {
                    let args = separated_by!(Comma, self.parse_expr(BindingPower::zero())?, RParen);
                    AST::Function(Box::new(lhs), args)
                }),
                
                // Infix operators
                token_type!(Star) => infix_op!(7, Left, Mul),
                token_type!(Plus) => infix_op!(6, Left, Add),
                token_type!(Minus) => infix_op!(6, Left, Sub),

                token_type!(Lt) => infix_op!(5, Left, LessThan),
                token_type!(LtEq) => infix_op!(5, Left, LessThanEqual),
                token_type!(Gt) => infix_op!(5, Left, GreaterThan),
                token_type!(GtEq) => infix_op!(5, Left, GreaterThanEqual),
                
                token_type!(EqEq) => infix_op!(4, Left, Equals),
                token_type!(NotEq) => infix_op!(4, Left, |rhs| {
                    AST::function(BuiltinFunction::Not, vec![AST::function(BuiltinFunction::Equals, vec![lhs, rhs])])
                }),

                token_type!(And) => infix_op!(3, Left, And),
                token_type!(Or) => infix_op!(2, Left, Or),

                _ => break,
            };
        }

        Ok(lhs)
    }

}

pub mod precedence {
    use std::cmp::Ordering;

    use crate::language::errors::Error;

    #[derive(Debug, Clone, Copy)]
    pub enum Assoc {
        Left,
        Right,
        None,
    }

    #[derive(Debug, Clone, Copy)]
    pub struct BindingPower(u8, Assoc);

    impl BindingPower {
        pub fn zero() -> Self {
            BindingPower(0, Assoc::None)
        }

        pub fn prefix(bp: u8) -> Self {
            BindingPower(bp, Assoc::None)
        }

        pub fn postfix(bp: u8) -> Self {
            BindingPower(bp, Assoc::None)
        }

        pub fn infix(bp: u8, assoc: Assoc) -> Self {
            BindingPower(bp, assoc)
        }
    }

    pub fn should_break(new_bp: &BindingPower, min_bp: &BindingPower) -> Result<bool, Error> {
        match Ord::cmp(&new_bp.0, &min_bp.0) {
                Ordering::Less => Ok(true),
                Ordering::Greater => Ok(false),
                Ordering::Equal => match (new_bp.1, min_bp.1) {
                    (Assoc::Left, Assoc::Left) => Ok(true),
                    (Assoc::Right, Assoc::Right) => Ok(false),
                    _ => Err(Error::parse_error("operator precedence error"))
                },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::super::s_exprs::ToSExpr;
    use super::*;

    macro_rules! test_parse_success {
        ($test_name:ident, $input:expr, $expected:expr) => {
            #[test]
            fn $test_name() {
                assert_eq!(parse($input).unwrap().to_s_expr(), $expected);
            }
        };
    }

    test_parse_success!(test_int, "5", "5");
    test_parse_success!(test_int2, "0", "0");
    test_parse_success!(test_string, "\"string\"", "\"string\"");
    test_parse_success!(test_list_lit, "[1, 2, 3]", "[1, 2, 3]");
    test_parse_success!(test_record_lit, "{b: 2, a: 1}", "{a: 1, b: 2}");
    test_parse_success!(test_plus, "1 + 2", "((builtin +) 1 2)");
    test_parse_success!(test_minus, "1 - 2", "((builtin -) 1 2)");
    test_parse_success!(test_multiply, "1 * 2", "((builtin *) 1 2)");
    test_parse_success!(test_negate, "-1", "((builtin negate) 1)");
    test_parse_success!(test_negate2, "--1", "((builtin negate) ((builtin negate) 1))");
    test_parse_success!(test_prec_left, "1 * 2 + 3", "((builtin +) ((builtin *) 1 2) 3)");
    test_parse_success!(test_prec_right, "1 + 2 * 3", "((builtin +) 1 ((builtin *) 2 3))");
    test_parse_success!(test_dot, "a.b", "(.b a)");
    test_parse_success!(test_dot2, "a.b.c", "(.c (.b a))");
    test_parse_success!(test_dot_prec_left, "a.b + c", "((builtin +) (.b a) c)");
    test_parse_success!(test_dot_prec_right, "a + b.c", "((builtin +) a (.c b))");

    test_parse_success!(test_lambda, "fn () -> 1", "(lambda () 1)");
    test_parse_success!(test_lambda2, "fn (x) -> x", "(lambda (x) x)");
    test_parse_success!(
        test_lambda3,
        "fn (x, y) -> x + y",
        "(lambda (x, y) ((builtin +) x y))"
    );

    test_parse_success!(test_let, "let x = 5 in x", "(let ((x 5)) x)");
    test_parse_success!(test_let2, "let x = 5; y = 3 in 1", "(let ((x 5) (y 3)) 1)");
    test_parse_success!(
        test_let_lambda,
        "let f = fn (x) -> x in f(5)",
        "(let ((f (lambda (x) x))) (f 5))"
    );
}
